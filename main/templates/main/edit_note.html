{% extends 'main/note_layout.html' %}
{% block title %}Edit Note{% endblock %}
{% block container_start %}
{{ form.errors }}
<section id="edit-iteration-container" class="hidden">
    <input type="text" name="title" class="hidden">
    <textarea name="text" class="edit" cols="30" rows="10"></textarea>
    <button type="button" class="save-edit">Save Edit</button>
    <button type="button" class="close">Close</button>
</section>
<form action="{% url 'edit_note' note.id %}" method="POST" id="note-edit-form">
{% csrf_token %}
{% endblock %}
{% block note_title %}
<tr>
    <th><h2>{{ form.title.label }}</h2></th>
    <td>{{ form.title }}</td>
</tr>
{% endblock %}
{% block iterations_one %}
<div class="iteration-input">
    {{ form.step_one_iterations }}
    <button class="add-button" type="button" data-which=1 data-length={{note.iterations_one|length}}>Add Iteration</button>
</div>
{% endblock %}
{% block form_links %}
<div class="iteration-input" style="display: flex; flex-direction: column; align-items: flex-start;">
    <div style="display: flex;">
        <label for="forwhich">Link for iteration: </label>
        <select name="forwhich" id="forwhich">
            {% for iteration in note.iterations_one %}
            <option value="{{ forloop.counter }}">{{ forloop.counter }}</option>
            {% endfor %}
        </select>
    </div>
    <input type="text" placeholder="Link Title" id="link-title">
    {{ form.links }}
    <button class="add-button" type="button" data-which=0 data-length={{note.links|length}}>Add Link</button>
</div>
{% endblock %}
{% block step_two_iterations %}
<div class="iteration-input">
    {{ form.step_two_iterations }}
    <button class="add-button" type="button" data-which=2 data-length={{note.iterations_two|length}}>Add Iteration</button>
</div>
{% endblock %}
{% block rest %}
<tr>
    <th>{{ form.step_three.label }}</th>
    <td>{{ form.step_three }}</td>
</tr>
<tr>
    <th>{{ form.understand.label }}</th>
    <td>{{ form.understand }}</td>
</tr>
<tr>
</tr>
{% endblock %}
{% block container_end %}
</form>
<button class="submit">Save</button>
{% endblock %}

{% block scripts %}
<script>
    // main form that encapsulates all the inputs
    const form = document.querySelector('#note-edit-form');

    // add buttons that appear next to iterations and links sections. 
    const addButtons = document.querySelectorAll('.add-button');

    // 'form' section that contains all the inputs needed to edit iteration sections (and links).
    const editIterationContainer = document.querySelector('#edit-iteration-container');

    // 1 = iterations_one
    // 0 = links
    // 2 = iterations_two
    // this object will be queried when the main form is submitted to retrieve information regarding (added, deleted, edited) iterations. 
    var iterations = {1: {}, 0: {}, 2:{}}; 

    // this function is run as an event funciton therefore, is passed e
    function addItem(object) {
        // using e (object) to access what was clicked aka the 'target'
        const target = object.target;
        // since we are adding an item we are going to increase the length dataset value of the button indicating that total iterations in the buttons section has increased by 1
        target.dataset.length = parseInt(target.dataset.length) + 1;

        // container which will store each iteration (not used for links because each link is stored inside a container.table-data, each link is a div.data in a div.table-data)
        const container = document.createElement('div');
        container.classList.add('table-data')

        // each div.table-data contains an h4 that lets the user know what a current iteration is
        // for normal iterations it would display what iteration a text is in example: Iteration X, followed by text
        // for links if there is not a link section for a certain step 1 section then this iterationHeader is used to display the following in the .table-data: "Links for iteration: x"
        const iterationHeader = document.createElement('h4');

        // this will store all the information of an item
        // purpose for separation is because the editIterationContainer is appended to each div.table-data giving the illusion of converting each row into its relative input.
        // in order to perform the illusion, we need to reveal the appended form and hide the data in table-data which is why I encapsulated the item data into a div of its own.
        const dataContainer = document.createElement('div'); 
        dataContainer.classList.add('data')

        // as stated before, target = button that was clicked, due to the layout of the form each add iteration(or link) button succeeds an input and or textarea.
        const input = target.previousElementSibling;

        const emptyIterationP = target.parentElement.parentElement.querySelector('p');
        if (emptyIterationP && emptyIterationP.innerText.startsWith('No')) {
            // remove since a new item is being added therefore no longer being empty 
            target.parentElement.parentElement.removeChild(emptyIterationP)
        }
        // garbage collect object
        emptyIterationP = null;

        // if the current button dataset value added does not exist
        if (target.dataset.added == null) {
            // assign an empty list to added key in the object
            // NOTE: that target.dataset.which is used to reference which iterations section we are on, above (where iterations was declared) a comment on which = certain section
            iterations[target.dataset.which].added = [];
            // update buttons dataset added value 
            target.dataset.added = true;
        }

        const generateSecret = () => {
            let result = '';
            for (let i = 0; i < 5; i++) {
                result += String.fromCharCode(Math.floor(Math.random()*126+1));
            }
            return result;
        }

        // if add item button of links was clicked
        if (target.dataset.which == 0) {
            // const deleteButton = document.createElement('button');
            // deleteButton.innerText = 'Delete';
            // deleteButton.addEvenListener('click', function() {
            //     if (iterations[target.dataset.which].deleted == null) {
            //         iterations[target.dataset.which].deleted = {}
            //     }
            //     // TODO ifnish this delete functionliaty
            //     # iterations[teraget.dataset.which].deleted[target.dataset.iteration].push(l= [iterationChoosen, ]

            // })
            
            // stores the value of which iteration section was selected to add this link too (links are grouped into specific sections, aka the iteration a certian link belongs too) 
            const iterationChoosen = parseInt(document.querySelector('#forwhich').value);
            const linkTitle = document.querySelector('#link-title');

            // each link contains the following format: [iteration of step 1 choosen, link title to be displayed when rendering, link href to be used]
            iterations[target.dataset.which].added.push([iterationChoosen, linkTitle.value, input.value]);

            // creating the a tag to store the newly added link
            const a = document.createElement('a');
            a.setAttribute('href', input.value)
            a.setAttribute('target', '_blank')
            a.innerText = linkTitle.value;

            // adding link to dataContainer
            dataContainer.appendChild(a)

            // garbage collect
            linkTitle = null;
        } else {
            const editButton = document.createElement('button');
            editButton.setAttribute('type', 'button')
            editButton.classList.add('edit-iteration')
            // settings the iteration dataset value to be the current buttons parents parent total length of .table-data divs plus one (plus one because we are adding this item)
            editButton.dataset.iteration = target.parentElement.parentElement.querySelector('.table-data') && target.parentElement.parentElement.querySelector('.table-data').length+1;
            editButton.dataset.which = target.dataset.which;
            editButton.innerText = 'Edit';
            editButton.addEventListener('click', editButtonFunctionality)

            dataContainer.appendChild(editButton);

            // format here is different than the format for links because this is simply adding text unlike links which contains iteration choosen, title, and text therefore we can simply concat a value with existing array in added
            iterations[target.dataset.which].added = iterations[target.dataset.which].added.concat(input.value);

            // since links is mainly meant for step 1 (solve after acquiring gaps in explanation) each time this newItem function is run on 1 (1 = new step 1 iteration) then add an option to store links
            // in the newly added iteration for step 1
            if (target.dataset.which == 1) {
                // add new option to links
                const option = document.createElement('option');
                // recall in the beginning of this newItem function we incremented the length value by 1 (self explanatory) therefore no need to querySelectorAll(.table-data).length to recieve the index of newly added iteration 
                option.value = target.dataset.length;
                option.innerText = target.dataset.length;
                document.querySelector('#forwhich').appendChild(option)
            }

            const p = document.createElement('p');
            p.innerText = input.value;
            dataContainer.appendChild(p)
        }

        // if button clicked to add new item is not links section
        if (target.dataset.which != 0) { 
            iterationHeader.innerText = `Iteration: ${target.dataset.length}`;
            container.appendChild(iterationHeader)
            container.appendChild(dataContainer)
            target.parentElement.parentElement.insertBefore(container, target.parentElement)
        } else if (target.dataset.which == 0 && document.querySelector('#links-data').querySelectorAll('.table-data').length >= parseInt(document.querySelector('#forwhich').value)) {
            // ^ if button was in links section and links section td contains table data whose index is relative to the forwhich value selected then append link to thus container
            document.querySelector('#links-data').querySelectorAll('.table-data')[parseInt(document.querySelector('#forwhich').value)-1].appendChild(dataContainer)
        } else if (target.dataset.which == 0 && document.querySelector('#links-data').querySelectorAll('.table-data').length <  parseInt(document.querySelector('#forwhich').value)) {
            // ^ otherwise if button in links section and links section td does not contain a table data of index equal to selected forwhich value
            iterationHeader.innerText = `Links for iteration: ${iterationChoosen}`;
            // append the container that encapsulates dataContainer (<div.table-data>__space for edit form___<div.data>__space for actual information such as p, a)
            container.appendChild(iterationHeader)
            container.appendChild(dataContainer)
            target.parentElement.parentElement.insertBefore(container, target.parentElement)
        }

        linkInput ? linkInput.value = "" : null;
        input.value = "";
    }

    addButtons.forEach(item => {
        item.addEventListener('click', addItem)
    })

    document.querySelector('.submit').addEventListener('click', function() {
        addButtons.forEach(item => {
            item.previousElementSibling.value = JSON.stringify(iterations[item.dataset.which]);
        })
        form.submit()
    })

    function editButtonFunctionality(object) {
        const target = object.target;
        console.log(target)
        // left off ehre was going to check whether the dataset was link to create a new input and save the title there, but no. don't give orde,r but group the links based on the iteration the user wants to add them too
        if (editIterationContainer.classList.contains('busy')) {
            editIterationContainer.querySelector('textarea').value = '';
            editIterationContainer.parentElement.querySelector('.data').classList.remove('hidden')
        }
        const data = target.parentElement.parentElement.querySelector('.data');
        data.classList.add('hidden')
        target.parentElement.parentElement.appendChild(editIterationContainer)
        editIterationContainer.classList.remove('hidden')
        editIterationContainer.querySelector('textarea').value = target.previousElementSibling.innerText;
        editIterationContainer.classList.add('busy')
        const saveEditButton = target.parentElement.parentElement.querySelector('.save-edit');
        saveEditButton.dataset.which = parseInt(target.dataset.which);
        saveEditButton.dataset.iteration = parseInt(target.dataset.iteration);
    }

    document.querySelectorAll('.edit-iteration').forEach(item => {
        item.addEventListener('click', editButtonFunctionality)
    })

    function toggleEditIterationContainer() {
        editIterationContainer.classList.add('hidden')
        editIterationContainer.classList.remove('busy')
        editIterationContainer.parentElement.querySelector('.data').classList.remove('hidden')
        editIterationContainer.querySelector('textarea').value = '';
        document.querySelector('body').appendChild(editIterationContainer)
    }

    // send back to body and hide
    editIterationContainer.querySelector('.close').addEventListener('click', toggleEditIterationContainer)

    editIterationContainer.querySelector('.save-edit').addEventListener('click', function() {
        // save response 
        const value = this.previousElementSibling.value;
        const iteration = this.dataset.iteration;
        if (iterations[this.dataset.which].edit == null) {
            iterations[this.dataset.which].edit = {};
        }
        if (this.dataset.which ==  0) {
            iterations[this.dataset.which].edit[iteration][1] = value.trim();
        } else {
            iterations[this.dataset.which].edit[iteration] = value.trim();
        }
        this.parentElement.parentElement.querySelector('.data').querySelector('p').innerText = value;

        toggleEditIterationContainer()
    })
</script>
{% endblock %}